{
  "name": "js-priority-queue",
  "version": "0.0.6",
  "description": "Priority queue data structures",
  "main": "index.js",
  "scripts": {},
  "repository": {
    "type": "git",
    "url": "https://github.com/adamhooper/js-priority-queue"
  },
  "keywords": [
    "priority",
    "queue",
    "bheap",
    "b-heap",
    "binary",
    "heap",
    "dequeue",
    "comparator"
  ],
  "author": {
    "name": "Adam Hooper",
    "email": "adam@adamhooper.com"
  },
  "license": "Public Domain",
  "readmeFilename": "README.md",
  "devDependencies": {
    "grunt": "~0.4.1",
    "grunt-contrib-coffee": "~0.7.0",
    "grunt-contrib-jasmine": "~0.5.1",
    "grunt-template-jasmine-requirejs": "~0.1.3",
    "grunt-requirejs": "~0.3.5"
  },
  "dependencies": {
    "amdefine": "~0.1.0"
  },
  "readme": "Priority Queue\n==============\n\nA priority queue is a data structure with these operations:\n\n| Operation | Syntax (js-priority-queue) | Description |\n| --------- | --- | ----------- |\n| Create | `var queue = new PriorityQueue();` | Creates a priority queue |\n| Queue | `queue.queue(value);` | Inserts a new value in the queue |\n| Length | `var length = queue.length;` | Returns the number of elements in the queue |\n| Peek | `var firstItem = queue.peek();` | Returns the smallest item in the queue and leaves the queue unchanged |\n| Dequeue | `var firstItem = queue.dequeue();` | Returns the smallest item in the queue and removes it from the queue |\n\nYou cannot access the data in any other way: you must dequeue or peek.\n\nWhy use this library? Two reasons:\n\n1. It's easier to use than an Array, and it's clearer.\n2. It can make your code execute more quickly.\n\nInstalling\n==========\n\nDownload `priority-queue.js`. Alternatively, install through Bower:\n`bower install js-priority-queue`\n\nInclude it through [RequireJS](http://requirejs.org/).\n\nThen write code like this:\n\n    require([ 'vendor/priority-queue' ], function(PriorityQueue) {\n      var queue = new PriorityQueue({ comparator: function(a, b) { return b - a; }});\n      queue.queue(5);\n      queue.queue(3);\n      queue.queue(2);\n      var lowest = queue.dequeue(); // returns 5\n    });\n\nIf you don't like RequireJS, you can download the standalone version,\n`priority-queue.no-require.js`, and write:\n\n    var queue = new PriorityQueue({ comparator: function(a, b) { return b - a; }});\n    queue.queue(5);\n    queue.queue(3);\n    queue.queue(2);\n    var lowest = queue.dequeue(); // returns 5\n\nOptions\n=======\n\nHow exactly will these elements be ordered? Let's use the `comparator` option.\nThis is the argument we would pass to\n[Array.prototype.sort](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/sort):\n\n    var compareNumbers = function(a, b) { return a - b; };\n    var queue = new PriorityQueue({ comparator: compareNumbers });\n\nYou can also pass initial values, in any order. With lots of values, it's\nfaster to load them all at once than one at a time.\n\n    var queue = new PriorityQueue({ initialValues: [ 1, 2, 3 ] })\n\nStrategies\n==========\n\nWe can implement this with a regular `Array`. We'll keep it sorted inversely,\nso `queue.dequeue()` maps to `array.pop()`.\n\nBut with an `Array`, we'll need to `splice()`, which can affect every single\nelement in the array. An alternative is to create a\n[Binary Heap](http://en.wikipedia.org/wiki/Binary_heap), which writes far\nfewer array elements when queueing (though each element is written more slowly).\n\nFinally, we can use a [B-Heap](http://en.wikipedia.org/wiki/B-heap). It's like a\nbinary heap, except it orders elements such that during a single operation,\nwrites occur closer to each other in memory. Unfortunately, it's slower to\ncalculate where in memory each write should occur (it costs a function call\ninstead of a bit-shift). So while it's fast in theory, it's slower in practice.\n\nCreate the queues like this:\n\n    var queue = new PriorityQueue({ strategy: PriorityQueue.ArrayStrategy }); // Array\n    var queue = new PriorityQueue({ strategy: PriorityQueue.BinaryHeapStrategy }); // Default\n    var queue = new PriorityQueue({ strategy: PriorityQueue.BHeapStrategy }); // Slower\n\nYou'll see running times like this:\n\n| Operation | Array | Binary heap | B-Heap |\n| --------- | ----- | ----------- | -------------- |\n| Create | O(n lg n) | O(n) | O(n) |\n| Queue | O(n) (often slow) | O(lg n) (fast) | O(lg n) |\n| Peek | O(1) | O(1) | O(1) |\n| Dequeue | O(1) (fast) | O(lg n) | O(lg n) |\n\nAccording to [JsPerf](http://jsperf.com/js-priority-queue-queue-dequeue), the\nfastest strategy for most cases is `BinaryHeapStrategy`. Only use `ArrayStrategy`\nonly if you're queuing items in a very particular order. Don't use\n`BHeapStrategy`, except as a lesson in how sometimes miracles in one\nprogramming language aren't great in other languages.\n\nContributing\n============\n\n1. Fork this repository\n2. Run `npm install`\n3. Write the behavior you expect in `spec-coffee/`\n4. Edit files in `coffee/` until `grunt test` says you're done\n5. Run `grunt` to update `priority-queue.js` and `priority-queue.min.js`\n6. Submit a pull request\n\nLicense\n=======\n\nI, Adam Hooper, the sole author of this project, waive all my rights to it and\nrelease it under the [Public\nDomain](http://creativecommons.org/publicdomain/zero/1.0/). Do with it what you\nwill.\n",
  "bugs": {
    "url": "https://github.com/adamhooper/js-priority-queue/issues"
  },
  "homepage": "https://github.com/adamhooper/js-priority-queue",
  "_id": "js-priority-queue@0.0.6",
  "_shasum": "76e11debf504072caa2d83f6218f7496d39e0c71",
  "_from": "js-priority-queue@",
  "_resolved": "https://registry.npmjs.org/js-priority-queue/-/js-priority-queue-0.0.6.tgz"
}
